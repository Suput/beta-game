<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.7.8/dist/vue.js"></script>

    <title>Document</title>
    <style>
        body {
            height: 100vh;
            /* background-color: red; */
            position: relative;
            margin: 0;
            overflow: hidden;
        }

        #app {
            height: 100%;
            flex-direction: column;
            background-color: rgba(50, 178, 253, 0.914);
        }

        .stage {
            height: 100%;
        }

        .gate {
            position: absolute;
            width: 60px;
            height: 60px;
        }

        .drone {
            position: relative;
            width: 40px;
            height: 40px;
        }

        .spin {
            animation: spin 1s ease-out 1;
        }

        @keyframes spin {
            from {
                transform: rotate(0)
            }

            to {
                transform: rotate(360deg)
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="stage" ref="stage">
            <img ref="drone" class="drone" src="assets/drone.svg"
                v-bind:style="{top: drone.pos.top+'px', left: drone.pos.left+'px'}">

            <div class="gates">
                <div v-for="(gate, index) in gates" v-bind:key="index">
                    <img class="gate" src="assets/gate.svg" v-bind:style="{top: gate.top+'px', left: gate.left+'px'}">
                </div>
            </div>
            <img class="gate" ref="gate" src="assets/gate.svg" style="position: absolute; left: -1000px">
        </div>
    </div>
</body>
<script>
    const SPEED = 300 // px/s
    const SCROLL_SPEED = 200
    const GATE_INTERVAL = 150

    var app = new Vue({
        el: '#app',
        data: {
            totalScroll: 0,
            lastGateSpawned: 0,
            previousTimestamp: 0,
            gate: {
                height: 0,
                width: 0
            },
            drone: {
                pos: {
                    top: 0,
                    left: 0
                },
                speed: {
                    vSpeed: 0,
                    hSpeed: 0
                }
            },
            // type Hoop = { top: number, left: number }
            gates: []
        },
        created() {
            window.addEventListener("keydown", this.keyDownHandler)
            window.addEventListener("keyup", this.keyUpHandler)

            window.requestAnimationFrame(this.gameLoop)
        },
        mounted() {
            const { offsetHeight: hStage, offsetWidth: wStage } = this.$refs.stage;
            const { offsetHeight: hDrone, offsetWidth: wDrone } = this.$refs.drone;
            const { offsetHeight: hGate, offsetWidth: wGate } = this.$refs.gate;

            this.drone.pos.top = hStage - hDrone - 60
            this.drone.pos.left = (wStage - wDrone) / 2
        },
        beforeDestroy() {
            window.removeEventListener("keydown", this.keyDownHandler)
            window.removeEventListener("keydown", this.keyDownHandler)
        },
        methods: {
            up() {
                this.drone.speed.vSpeed = -SPEED
            },
            down() {
                this.drone.speed.vSpeed = SPEED
            },
            left() {
                this.drone.speed.hSpeed = -SPEED
            },
            right() {
                this.drone.speed.hSpeed = SPEED
            },
            stop({ vertical, horizontal }) {
                if (vertical) {
                    this.drone.speed.vSpeed = 0
                }
                if (horizontal) {
                    this.drone.speed.hSpeed = 0
                }
            },
            keyDownHandler(e) {
                // console.log('keyDownHandler', e)
                if (e.code === "ArrowUp") {
                    this.up()
                }
                if (e.code === "ArrowDown") {
                    this.down()
                }
                if (e.code === "ArrowRight") {
                    this.right()
                }
                if (e.code === "ArrowLeft") {
                    this.left()
                }
            },
            keyUpHandler(e) {
                // console.log('keyUpHandler', e)
                if (e.code === "ArrowUp" || e.code === "ArrowDown") {
                    this.stop({ vertical: true })
                }
                if (e.code === "ArrowRight" || e.code === "ArrowLeft") {
                    this.stop({ horizontal: true })
                }
            },
            gameLoop(timestamp) {
                // console.log('this.drone.speed.vSpeed', this.drone.speed.vSpeed)
                const dT = timestamp - this.previousTimestamp
                const dX = dT / 1000 * this.drone.speed.hSpeed
                const dY = dT / 1000 * this.drone.speed.vSpeed

                const dS = dT / 1000 * SCROLL_SPEED
                this.totalScroll += dS

                if (this.totalScroll - this.lastGateSpawned > GATE_INTERVAL) {
                    if (this.gates.length < 10) {
                        this.gates.push(this.spawnGate())
                        this.lastGateSpawned = this.totalScroll;
                    }
                }

                if (this.gates.length > 0 && this.gates[0].top > this.$refs.stage.offsetHeight) {
                    this.gates.shift()
                }

                this.gates.forEach(element => {
                    element.top += dS
                });

                // console.log('dX', dX)

                this.drone.pos.left = this.cap(this.drone.pos.left + dX, 0, this.$refs.stage.offsetWidth - this.$refs.drone.offsetWidth)
                this.drone.pos.top = this.cap(this.drone.pos.top + dY, 0, this.$refs.stage.offsetHeight - this.$refs.drone.offsetHeight)

                this.previousTimestamp = timestamp
                window.requestAnimationFrame(this.gameLoop)
            },
            cap(param, min, max) {
                if (param < min) return min
                if (param > max) return max
                return param
            },
            spawnGate() {
                const maxX = this.$refs.stage.offsetWidth - this.$refs.gate.offsetWidth;

                return { top: 0, left: Math.random() * maxX }
            }
        }
    })
</script>

</html>